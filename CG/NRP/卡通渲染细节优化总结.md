# 卡通渲染细节优化总结

## 刘海投影

### 方式：模板

## 二、实现

### 1.半透明材质模板测试

首先设置好面部模板值，这里是1（需要单独将脸部拆出，使阴影不遮盖其他部分）。

![img](https://pic4.zhimg.com/80/v2-f42d7bce1c52c002c6e6ae1034c2b353_720w.webp)

001

上期将发片在蓝图里进行了偏移这里不再进行偏移。

![img](https://picx.zhimg.com/80/v2-0dcf2569e6bed40b677c8a6e0449d6bb_720w.webp)

000

在半透明材质里将模板值用于不透明度上（有看不懂的部分先看上集）

![img](https://pic2.zhimg.com/80/v2-e7fe90738c70cf5cd8b255b5d003301f_720w.webp)

Stencil Test

“上色”

![img](https://pic2.zhimg.com/80/v2-dec72eb21026d2d0c4f9bd9e05557a1b_720w.webp)

Color

自发光可连可不连，仅调色使用

### 方式：深度偏移

### 1.2 实现方式

流朔大佬很久之前就实现过一个不错的刘海投影效果，主要思想是给头发或脸部绘制模板，然后在屏幕空间下进行偏移，进行模板测试：

[流朔：【Unity URP】以Render Feature实现卡通渲染中的刘海投影1049 赞同 · 49 评论文章![img](https://pic4.zhimg.com/v2-012946fe8783a54f47c2d72466f3e29b_180x120.jpg)](https://zhuanlan.zhihu.com/p/232450616)

[流朔：【Unity URP】卡通渲染中的刘海投影·改169 赞同 · 10 评论文章![img](https://pica.zhimg.com/v2-480796738bf65f1546331545d5adbc46_180x120.jpg)](https://zhuanlan.zhihu.com/p/416577141)

由于我们UE做的是延迟渲染，做起来这个效果就更简单了，在做脸部shading时，偏移一下屏幕空间的深度信息和头发的深度进行对比，直接就能得到刘海投影。在加上上一篇文章写入了ToonModel，已经把头发和脸部区分好了，做起刘海投影更是如鱼得水。

### 二、实现

本文很大半篇幅在修改ToonBuffer，如果只想看头发投影的实现，建议直接跳到：**2.3 添加头发投影**。

### 2.1 Light Shader读取ToonBuffer

以我目前的修改，只有Raytracing Shadow的Shader可以读取到ToonBuffer，这次的刘海投影在Lighting Pass中计算，我们需要让Lighting的Shader也读取ToonBuffer里的信息。

UE计算Lighting使用的是DeferredLightPixelShaders.usf，我们可以发现它最终是使用GetGBufferData函数来获取GBuffer信息。

![img](https://pica.zhimg.com/80/v2-345e6bfb21e32c0ee1986b425de86da0_720w.webp)

![img](https://pic4.zhimg.com/80/v2-843040c21f8e36ca0081c297514c0d8f_720w.webp)

DeferredShadingCommon.ush

我们可以在这里加上对ToonBuffer的采样：

![img](https://picx.zhimg.com/80/v2-e0929789d814cd0f6ebfcd169caed53f_720w.webp)

DeferredShadingCommon.ush

但是这么改完了之后，会发现一点效果都没有，这是因为默认情况下走的是这个分支

![img](https://picx.zhimg.com/80/v2-3db45e751c3096f9464e684bbf821bf9_720w.webp)

这个函数你[全局搜索](https://zhida.zhihu.com/search?q=全局搜索&zhida_source=entity&is_preview=1)是搜不出来的，因为它是在C++中生成的。具体是怎么生成的呢，可以看看ShaderGenerationUtil.cpp。

如果想看到它生成的代码，我们可以用[Visual Studio](https://zhida.zhihu.com/search?q=Visual+Studio&zhida_source=entity&is_preview=1)打开工程，在上面打个断点，debug一下看看这个OutputFileData。

![img](https://picx.zhimg.com/80/v2-92c19e0ec1b8a4c8f51f505ea4c65075_720w.webp)

ShaderGenerationUtil.cpp

DecodeGBufferData函数在这个函数里生成，会生成四种DecodeGBufferData函数：

- DecodeGBufferDataUV
- DecodeGBufferDataUint
- DecodeGBufferDataSceneTextures
- DecodeGBufferDataSceneTexturesLoad

![img](https://pica.zhimg.com/80/v2-6b5d564fbdc4e37a69abb6be04deca7c_720w.webp)

ShaderGenerationUtil.cpp

![img](https://picx.zhimg.com/80/v2-d896102a80bf29b9a6f32c77d8d5e9d9_720w.webp)

把OutputFileData复制到VS Code查看

由于DeferredLightPixelShaders.usf里用的是DecodeGBufferDataUV，所以我也先只在DecodeType == CoordUV时加上TBuffer的采样，如果以后用到了其他的三个，到时候再加。

![img](https://pic2.zhimg.com/80/v2-55f9e9c263262f782892250198a0f049_720w.webp)

ShaderGenerationUtil.cpp

![img](https://pica.zhimg.com/80/v2-42bfb786e28c70d2295a14fdc7a6e740_720w.webp)

ShaderGenerationUtil.cpp

接下来我们还要修改一下这个DecodeGBufferDataDirect函数，它是由CreateGBufferDecodeFunctionDirect生成的

![img](https://pic4.zhimg.com/80/v2-6c41339ab299d502a9e7de2a26d4fe15_720w.webp)

OutputFileData生成的代码

![img](https://pic4.zhimg.com/80/v2-a45d685074138dd1b5126b99fa8c73cb_720w.webp)

ShaderGenerationUtil.cpp

我没有直接修改CreateGBufferDecodeFunctionDirect函数，而是定义了个GBufferDecodeFunctionDirectOveride来生成DecodeGBufferDataDirect函数的重载：

```c
static FString GBufferDecodeFunctionDirectOveride(const FGBufferInfo& BufferInfo)
{
	FString FullStr;

	//------------------------------------------------函数头--------------------------------------------------
	FullStr += TEXT("FGBufferData  DecodeGBufferDataDirect(");
	bool bFirst = true;
	for (int32 Index = 0; Index < FGBufferInfo::MaxTargets; Index++)
	{
		const EGBufferType Target = BufferInfo.Targets[Index].TargetType;

		if (Target != GBT_Invalid && Index != 0)
		{
			if (bFirst)
			{
				bFirst = false;
			}
			else
			{
				FullStr += TEXT(",\n\t");
			}

			int32 NumChan = GetTargetNumChannels(Target);
			FString TypeName = GetFloatType(NumChan);
			FString CurrLine = FString::Printf(TEXT("%s InMRT%d"),
				TypeName.GetCharArray().GetData(),
				Index);

			FullStr += CurrLine;
		}
	}
	if (!bFirst)
	{
		FullStr += TEXT(",\n\t\t");
	}
	// 参数中加入TBuffer
	FullStr += TEXT(" \n\tuint4 InTBufferA,");
	FullStr += TEXT(" \n\tuint4 InTBufferB,");
	FullStr += TEXT(" \n\tuint4 InTBufferC,");
	FullStr += TEXT(" \n\tfloat CustomNativeDepth");
	FullStr += TEXT(",\n\tfloat4 AnisotropicData");
	FullStr += TEXT(",\n\tuint CustomStencil");
	FullStr += TEXT(",\n\tfloat SceneDepth");
	FullStr += TEXT(",\n\tbool bGetNormalizedNormal");
	FullStr += TEXT(",\n\tbool bChecker)\n");

	FullStr += TEXT("{\n");

	//------------------------------------------------函数Body--------------------------------------------------

	// 先使用默认的DecodeGBufferDataDirect函数
	FullStr += TEXT("\tFGBufferData Ret = DecodeGBufferDataDirect(");
	bFirst = true;
	for (int32 Index = 0; Index < FGBufferInfo::MaxTargets; Index++)
	{
		const EGBufferType Target = BufferInfo.Targets[Index].TargetType;

		if (Target != GBT_Invalid && Index != 0)
		{
			if (bFirst)
			{
				bFirst = false;
			}
			else
			{
				FullStr += TEXT(",\n\t\t");
			}

			int32 NumChan = GetTargetNumChannels(Target);
			FString CurrLine = FString::Printf(TEXT("InMRT%d"),
				Index);

			FullStr += CurrLine;
		}
	}

	if (!bFirst)
	{
		FullStr += TEXT(",\n\t\t");
	}
	
	FullStr += TEXT(" \n\t\tCustomNativeDepth");
	FullStr += TEXT(",\n\t\tAnisotropicData");
	FullStr += TEXT(",\n\t\tCustomStencil");
	FullStr += TEXT(",\n\t\tSceneDepth");
	FullStr += TEXT(",\n\t\tbGetNormalizedNormal");
	FullStr += TEXT(",\n\t\tbChecker);\n");

	//使用DecodeToonDataFromBuffer解码Toon部分
	FullStr += TEXT(" \n\tif (Ret.ShadingModelID == SHADINGMODELID_TOON)");
	FullStr += TEXT(" \n\t{");
	FullStr += TEXT(" \n\t\tRet.ToonBuffer = DecodeToonDataFromBuffer(InTBufferA, InTBufferB, InTBufferC, InMRT4);");
	FullStr += TEXT(" \n\t}");

	//------------------------------------------------Return-----------------------------------------------
	FullStr += TEXT("\n");
	FullStr += TEXT("\treturn Ret;\n");

	FullStr += TEXT("}\n");
	FullStr += TEXT("\n");
	
	return FullStr;
}
```

上面的函数生成的代码大概长这样：

![img](https://pic2.zhimg.com/80/v2-e0d306309552b3311471bfd829a923cb_720w.webp)

GBufferDecodeFunctionDirectOveride生成的代码

这里真的很想吐槽UE要这么生成代码，可能是为了提高一些代码复用，但是这样修改起代码来真的很麻烦，很不直观，一个这么简单的函数，C++写了100多行，红豆泥逆天。

把它加到这里：

![img](https://pic2.zhimg.com/80/v2-da1393c8fe16b24991c1ea29801bcfa1_720w.webp)

ShaderGenerationUtil.cpp

现在DeferredLightPixelShaders.usf应该就能读取到ToonBuffer了，这里我写了一点测试代码，让SelfID == 255的时候LightAttenuation等于0

![img](https://pica.zhimg.com/80/v2-f2c53f3562277e7f595962904056d948_720w.webp)

然后给脸部的SelfID写入255，脸部的光照消失了，说明ToonBuffer成功读取到了。

![img](https://pic2.zhimg.com/80/v2-28752b9f0e9cfdeb9b92006d0e299e5f_720w.webp)

### 2.2 修改ToonMaterial节点

之前材质编辑器为了写入ToonBuffer还要写Custom节点，有点麻烦

![img](https://pic4.zhimg.com/80/v2-4c5cd9e1c3566d8afdbd7798bc222167_720w.webp)

我打算把Toon Material节点改成下面这样：

![img](https://picx.zhimg.com/80/v2-2cb9079bd40c977a693859afef3b8907_720w.webp)

修改针脚名称：

![img](https://pic1.zhimg.com/80/v2-3d6f4849b04a3135b3d641d5b2fd244a_720w.webp)

MaterialExpressionToonMaterialOutput.h

添加一个GetInputType函数，用来定义针脚接受什么类型的输入：

![img](https://pic2.zhimg.com/80/v2-76a2cc9430130ba7f7c754f7fe174eb1_720w.webp)

MaterialExpressionToonMaterialOutput.h

在MaterialExpressions.cpp中实现UMaterialExpressionToonMaterialOutput::GetInputType

```c
uint32 UMaterialExpressionToonMaterialOutput::GetInputType(int32 InputIndex)
{
	if (InputIndex == 0) { return MCT_Float1; }		// SelfID
	if (InputIndex == 1) { return MCT_Float1; }		// ObjectID
	if (InputIndex == 2) { return MCT_Float1; }		// ToonModel
	if (InputIndex == 3) { return MCT_Float1; }		// ShadowCastFlag
	if (InputIndex == 4) { return MCT_Float1; }		// HairShadowOffset
	if(InputIndex < 7)
	{
		return MCT_Float4;
	}
	check(false);
	return MCT_Float3;
}
```

然后修改一下UMaterialExpressionToonMaterialOutput::Compile

![img](https://pic4.zhimg.com/80/v2-16a0971500d1bf18d3c3ae38c4a3bb65_720w.webp)

MaterialExpressions.cpp

修改输出节点数量：

![img](https://pic3.zhimg.com/80/v2-df47a1e50c336be385c3a2aa1d0eaa46_720w.webp)

MaterialExpressions.cpp

这样输出节点就修改好了。

接下来修改一下Engine/Shaders/Private/Toon/ToonPassShader.usf里的MainPS函数，把针脚信息正确写入ToonBuffer中。下面我把读取针脚和编码ToonBuffer的逻辑封装为两个函数：GetToonBuffer和EncodeToonBuffer

![img](https://pic1.zhimg.com/80/v2-ab105c6237473698c46c44501c2d670a_720w.webp)

我把Engine/Shaders/Private/Toon/ToonShadingCommon.ush改名为ToonBufferCommon.ush，并且添加了两个文件：ToonShadingCommon.ush和ToonMaterialParameterCommon.ush

![img](https://pic1.zhimg.com/80/v2-16d376da23172e655e2d1daa83b26d0c_720w.webp)

下面截出来的修改并不全，具体改了哪些东西大家去git看提交记录吧，全部截出来太长了。

像ToonStep这些和光照相关的放ToonShadingCommon.ush里，等一下计算头发投影也会放这里面：

![img](https://pic1.zhimg.com/80/v2-8cd9732b74d4a396070c611ee31ebf38_720w.webp)

ToonBufferCommon.ush里多了个EncodeToonBuffer和GetToonPayloadByToonBuffer函数

![img](https://pic3.zhimg.com/80/v2-023f9d546d570c04edfacb13053486c2_720w.webp)

ToonBufferCommon.ush

![img](https://pic3.zhimg.com/80/v2-feadceff9bcb6564af0790709106eb40_720w.webp)

ToonBufferCommon.ush

ToonMaterialParameterCommon.ush则是放了通过FMaterialPixelParameters来获取ToonBuffer和ToonPayloadData的函数。

```c
#pragma once

#include "../Common.ush"
#include "ToonBufferCommon.ush"

FToonBuffer GetToonBuffer(FMaterialPixelParameters MaterialParameters)
{
	FToonBuffer ToonBuffer;
	ToonBuffer.SelfID = 0;
	ToonBuffer.ObjectID = 0;
	ToonBuffer.ToonModel = 0;
	ToonBuffer.ShadowCastFlag = 0;
	ToonBuffer.HairShadowOffset = 0.0f;
	ToonBuffer.ToonBufferB = 0.0f;
	ToonBuffer.ToonBufferC = 0.0f;
#ifdef  HAVE_GetToonMaterialOutput0	
	ToonBuffer.SelfID = clamp(GetToonMaterialOutput0(MaterialParameters), 0.0f, 255.0f);
#endif
#ifdef  HAVE_GetToonMaterialOutput1	
	ToonBuffer.ObjectID = clamp(GetToonMaterialOutput1(MaterialParameters), 0.0f, 255.0f);
#endif
#ifdef  HAVE_GetToonMaterialOutput2	
	ToonBuffer.ToonModel = clamp(GetToonMaterialOutput2(MaterialParameters), 0.0f, 7.0f);
#endif
#ifdef  HAVE_GetToonMaterialOutput3	
	ToonBuffer.ShadowCastFlag = clamp(GetToonMaterialOutput3(MaterialParameters), 0.0f, 32.0f);
#endif
#ifdef  HAVE_GetToonMaterialOutput4	
	ToonBuffer.HairShadowOffset = GetToonMaterialOutput4(MaterialParameters);
#endif
#ifdef  HAVE_GetToonMaterialOutput5	
	ToonBuffer.HairShadowOffset = GetToonMaterialOutput4(MaterialParameters);
#endif
#ifdef  HAVE_GetToonMaterialOutput6	
	ToonBuffer.HairShadowOffset = GetToonMaterialOutput4(MaterialParameters);
#endif

	return ToonBuffer;
}

FToonPayloadData GetToonPayloadData(FMaterialPixelParameters MaterialParameters)
{
	FToonBuffer ToonBuffer = GetToonBuffer(MaterialParameters);
	
	return GetToonPayloadByToonBuffer(ToonBuffer);
}
```

后面还有include头文件，RayTracingOcclusionRGS.usf和RayTracingMaterialHitShaders.usf的修改

![img](https://picx.zhimg.com/80/v2-aeb0e492a4e550683102beb0caf744bf_720w.webp)

具体的修改都在这个提交记录里，还是看直接看git更清楚点：

![img](https://picx.zhimg.com/80/v2-11bb48b3d101064e1e0d6d0fc61c2099_720w.webp)

### 2.3 添加头发投影

接下来终于可以正式添加头发的投影了。一共就改了两个文件，代码量很少，为了显得本文没那么水，下面分步骤进行修改。

在DeferredLightPixelShaders.usf里把ToonShadingCommon.ush包括进去

![img](https://picx.zhimg.com/80/v2-a4381d0c35e5f65803659e56c5b24af1_720w.webp)

当ShadowModel是Toon并且是ToonFace或ToonEye的时候，使用GetHairShadow计算头发投影：

![img](https://pic3.zhimg.com/80/v2-55a2538e51a5267bdc6bbed17a223fa2_720w.webp)

DeferredLightPixelShaders.usf

GetHairShadow函数放在ToonShadingCommon.ush中实现：

```c
float GetHairShadow(FGBufferData GBuffer, FDeferredLightData LightData, float2 ScreenUV)
{
	float Shadow = 1.0f;
	float k = 100.0f;
	// 屏幕空间LightDirection
	// View.TranslatedWorldToCameraView用于将世界空间变换到屏幕空间
	float3 LightDirVS = mul(LightData.Direction, (float3x3)(View.TranslatedWorldToCameraView));
	// 翻转LightDirVS的y方向，不然Offset上下会反，可能会出现OpenGL和DirectX不一致的情况，不过到时候遇到再改
	LightDirVS.y = -LightDirVS.y;
	// 修正摄像机距离对偏移距离的影响
	LightDirVS *= (100.0f / CalcSceneDepth(ScreenUV));

	// View.BufferSizeAndInvSize.xy是屏幕分辨率；View.BufferSizeAndInvSize.xy是屏幕分辨率的倒数
	float2 Offset = LightDirVS.xy * k * GBuffer.ToonBuffer.HairShadowOffset * View.BufferSizeAndInvSize.zw;
	float2 OffsetedUV = ScreenUV + Offset;
	
	FGBufferData OffsetedGBuffer = GetGBufferData(OffsetedUV);

	if (OffsetedGBuffer.ToonBuffer.ToonModel == TOONMODEL_HAIR
		&& OffsetedGBuffer.ToonBuffer.ObjectID == GBuffer.ToonBuffer.ObjectID)
	{
		Shadow = 0.0f;
	}
	
	return Shadow;
};
```

上面的代码中，我们使用View.TranslatedWorldToCameraView将光源方向变换到屏幕空间。

关于View这个Buffer，我们可以在FRenderLightParameters中找到，各种矩阵和视图相关的信息都是通过这个Buffer传递给shader的。

![img](https://pic2.zhimg.com/80/v2-641f41b13306904feb87f21dc71f2a79_720w.webp)

而View.BufferSizeAndInvSize则是屏幕分辨率信息，如果分辨率1920x1080，

则BufferSizeAndInvSize.xy等于1920和1080，BufferSizeAndInvSize.zw等于1/1920和1/1080。

计算Offset的时候乘上BufferSizeAndInvSize.zw是为了保证计算出来的offset不会受分辨率影响。

![img](https://pic2.zhimg.com/80/v2-230c442618761952ae7fe79bd5bbe885_720w.webp)

添加上对Depth的判断消除脸部后面头发的投影

目前的代码还有点问题，添加上对Depth的判断来避免脸部采样到后面的头发

```c
if (OffsetedGBuffer.ToonBuffer.ToonModel == TOONMODEL_HAIR && OffsetedGBuffer.Depth < ScreenSpaceData.GBuffer.Depth)
{  
    HairShadow = 0.0f;  
}
```

可以看到离相机距离不同，Offset距离不一样：

![img](https://pic4.zhimg.com/80/v2-eb1f337f9b9fe8f49c166924ed8eb62f_720w.webp)

可以使用场景深度来修正Offset距离，使用CalcSceneDepth可以得到场景相对于相机的世界空间距离，也就是Clip Space Position的w分量（乘上100.0f是因为深度太大了，防止offset太小）。

```c
LightDirVS *= (100.0f / CalcSceneDepth(ScreenUV));
```

![img](https://picx.zhimg.com/80/v2-650d3a26bd17553f7bd871b5e9877b79_720w.webp)

当离屏幕太近的时候，会采样到屏幕之外，加一个saturate可以一定程度减少问题，但无法完全解决，这是屏幕空间算法很难避免的问题。

```c
float2 OffsetedUV = saturate(InputParams.ScreenUV + Offset);
```

![img](https://pica.zhimg.com/80/v2-8bc0926aab8394f409a8bc7b24369b44_720w.webp)

加一个saturate一定程度上减少采样到屏幕外的问题

如果想完全解决采样到屏幕外的问题，可以改成在MeshDraw Pass中绘制头发投影，但是我都写到这一步了，就懒得再动它了，以后有空再改，反正这么近的gachi恋距离也不常见。



当有多个光源的时候，也会出现头发的投影，这个我们并不希望出现，可以把主光源之外的头发投影都去除掉：

```c
bool IsMainLight = !LightData.bRadialLight && all(LightData.Direction == View.AtmosphereLightDirection[0].xyz);
```

![img](https://pica.zhimg.com/80/v2-4dac65afb01f04f4e534b53926f99a72_720w.webp)

完整的GetHairShadow函数：

```c
float3 GetMainLightDirection()
{
	return View.AtmosphereLightDirection[0].xyz;
}

bool IsMainLight(FDeferredLightData LightData)
{
	return !LightData.bRadialLight && all(LightData.Direction == GetMainLightDirection());
}

float GetHairShadow(FGBufferData GBuffer, FDeferredLightData LightData, float2 ScreenUV)
{
	float Shadow = 1.0f;
	
	if (!IsMainLight(LightData))
	{
		return Shadow;
	}
	
	float k = 100.0f;
	// 屏幕空间LightDirection
	// View.TranslatedWorldToCameraView用于将世界空间变换到屏幕空间
	float3 LightDirVS = mul(LightData.Direction, (float3x3)(View.TranslatedWorldToCameraView));
	// 翻转LightDirVS的y方向，不然Offset上下会反，可能会出现OpenGL和DirectX不一致的情况，不过到时候遇到再改
	LightDirVS.y = -LightDirVS.y;
	// 修正摄像机距离对偏移距离的影响
	LightDirVS *= (100.0f / CalcSceneDepth(ScreenUV));

	// View.BufferSizeAndInvSize.xy是屏幕分辨率；View.BufferSizeAndInvSize.xy是屏幕分辨率的倒数
	float2 Offset = LightDirVS.xy * k * GBuffer.ToonBuffer.HairShadowOffset * View.BufferSizeAndInvSize.zw;
	float2 OffsetedUV = saturate(ScreenUV + Offset);
	
	FGBufferData OffsetedGBuffer = GetGBufferData(OffsetedUV);

	if (OffsetedGBuffer.ToonBuffer.ToonModel == TOONMODEL_HAIR
		&& OffsetedGBuffer.Depth < GBuffer.Depth
		&& OffsetedGBuffer.ToonBuffer.ObjectID == GBuffer.ToonBuffer.ObjectID)
	{
		Shadow = 0.0f;
	}
	
	return Shadow;
};
```



## 面部sdf阴影优化





## 阴影控制-shadingRig



## Ramp Shadow（常用）







## 半透眉毛

方式一：使用模板测试写入遮罩，自定义眉毛stencil值为a，头发为b，叠加部分（叠加部分 = 自定义模板区域 - （场景深度 - 自定义的深度阈值））为a+b，对眉毛重合区域的头发部分使用半透明，其它部分用不透明，然后根据相机与角色Forward夹角，减少透明度。

本篇将大量使用此材质函数，建议提前创建好：

DeBugIf：

![img](https://pic1.zhimg.com/80/v2-11ed6eb4e2221c5e35d32186cc7882c6_720w.webp)

开始前我们先了解三个概念：CustomDepth、SceneDepth和CustomStencil

SceneDepth：场景深度，遮挡物场景深度，被遮挡部分不存在深度

![img](https://pica.zhimg.com/80/v2-4192012996867be0ef8d62ad14e74134_720w.webp)

![img](https://pic4.zhimg.com/80/v2-304ea817b483cbdb9076f2827d02eae5_720w.webp)

CustomDepth：自定义深度，物体Detail中可设定，是相对于SceneDepth的一个远平面，开启后的深度值与SceneDepth相同

![img](https://pic2.zhimg.com/80/v2-486526284fa58351ecbe04f050f1d9fb_720w.webp)

![img](https://picx.zhimg.com/80/v2-09917f9a0f6f759c7542828ce38b250b_720w.webp)

*开启自定义深度后比较值

![img](https://pic4.zhimg.com/80/v2-93a7e5a81bb6b5f9af13d0ce8ed9b9cd_720w.webp)

![img](https://pic2.zhimg.com/80/v2-e5eab5fbc2685d411b5ac17d25eaa263_720w.webp)

CustomStencil：

在Buffer中单独存在的一层信息，仅有一层，两自定义深度物体重叠时，深度信息将使用靠前物体的模版值，**重叠信息可通过自定义深度模板写入遮罩生成**。

![img](https://picx.zhimg.com/80/v2-3a160520a58e1fc046f0ee551607bff5_720w.webp)

开始制作：（用到模板值的记得在项目设置渲染中启用模板）

一、遮挡显示的简单应用

*先通过一个小案例了解如何让被遮挡物体显示。

1、通过自定义模板得到物体完整深度值（限制为1）

![img](https://pic4.zhimg.com/80/v2-e1ceff6267f9ef39eacac6425be599e5_720w.webp)

![img](https://pica.zhimg.com/80/v2-f0c442fdc088979bec44b02e10bd18f0_720w.webp)

![img](https://pic4.zhimg.com/80/v2-51ff4ffbe4357788d90c3774708af34d_720w.webp)

2、通过自定义深度与场景深度做运算得到未被遮挡部分（限制为1）

![img](https://pic4.zhimg.com/80/v2-08545c1ecbc12f1a4cb0227734d1058d_720w.webp)

![img](https://picx.zhimg.com/80/v2-8b69184c8a897e02003ea03bd7416c37_720w.webp)

*为什么不直接比较自定义深度与场景深度——会把背景也算进去，背景深度便是自定义深度的远平面深度

![img](https://pica.zhimg.com/80/v2-09f3922b14623783ca048fbf993a7188_720w.webp)

![img](https://pic1.zhimg.com/80/v2-a0ac0fe7dffcb50c2bdbce640b7f7044_720w.webp)

3、将步骤1与步骤2相减得到遮挡部分：

![img](https://pic4.zhimg.com/80/v2-07d88ffbdf702eae3741dfb7ea85857b_720w.webp)

![img](https://pic2.zhimg.com/80/v2-1630ce4e92e3b62142d7bfe5a477c891_720w.webp)

4、得到遮挡信息便可以随意操作了

![img](https://picx.zhimg.com/80/v2-6123935eebfbc8675026189e78f36a67_720w.webp)

![img](https://pica.zhimg.com/80/v2-172da756b8213801326ec07e506730a2_720w.webp)

5、但是，两自定义模板物体无法通过一张自定义模板buffer表示遮挡

*当开启遮挡物深度值，可以使遮挡物不显示被遮挡物体

![img](https://pic1.zhimg.com/80/v2-17c0325bedfb91b1822a9f79b9ca2288_720w.webp)

![img](https://pic1.zhimg.com/80/v2-6e64be0a6bbbec42355687b4cfc77148_720w.webp)

*这点特性也比较实用，但是，做人物眉毛时，我们需要在有自定义模板值的头发前提下，制作眉毛透过效果，这时需要新的思路。

二、制作眉毛透过效果

1、思路讲解：

将自定义模具分块，同时存在时叠加模具值即可，官方也为这种方法提供了便利。

*自定义模板写入遮罩：

![img](https://pic4.zhimg.com/80/v2-8136b6525c445e9c2db410c7d90cc009_720w.webp)

上图不难看出，未被遮罩的身体模具值为3，衣服开启写入遮罩并设定默认值为64，在被身体遮挡后，与前方物体相加，变成了67，通过这一点，我们可以获取两自定义模具的遮罩信息。

*使用规范建议：

![img](https://picx.zhimg.com/80/v2-4cb32d0affddd53ff67321ff3bf3f5ff_720w.webp)

自定义模板值在0-255之间，根据项目需求，可以选择上图值用作需要遮罩物体的起始值

例：我选择了第八位（128），则0-127用于存放无需遮罩物体，128用于存放需要遮罩物体，129-255用于获取遮罩值。

2、开始制作：

*获取遮罩部分并添加底色：

![img](https://pic4.zhimg.com/80/v2-0ade1cf3ff9efbc301e22eb41b21472d_720w.webp)

效果：

![img](https://pic4.zhimg.com/80/v2-34e6bb440104c386d34d0a6daa079b15_720w.webp)

*将遮罩物、被遮罩物和遮罩遮挡部分叠加获取后处理处理效果范围：

![img](https://pic2.zhimg.com/80/v2-f8f7ab8e1d9c3f0ac54b38245dcd2271_720w.webp)

效果：

![img](https://pic3.zhimg.com/80/v2-cb3db841c12b322975d1157919403d52_720w.webp)

## 

刘海阴影常见的做法也是RT和模板，RT的做法目前来说已经过时，移动端项目严格控制带宽不再多做赘述。

UE中目前的Stencil可以说是非常的不友好（蠢），是个逐Component的Stencil，这一块需要改源码去实现。

具体方式可以参考源码中TwoSide方式去做，不过在Instance的地方有个奇怪的Bug如果一个Instance的材质上静态开关默认全部关闭那么这个Instance的材质将会变成Parent，这玩意非常坑爹搞了我好久。

获取到Stencil之后就比较方便了,

渲染顺序： 脸 头发 偏移的头发（阴影）或者 脸 偏移的头发（阴影） 头发

一种是需要飘眉的半透前额发，一种是无飘眉的单纯额发阴影。 带飘眉的这种前置条件是建模的时候把前额发拆出来BaseColor.a画入需要半透区域的Mask。





![img](https://pic2.zhimg.com/80/v2-2603103ecbb61b4df856f7e610ca2973_720w.webp)

逐MaterialStencil

![img](https://pic1.zhimg.com/80/v2-b54341c46d35849d3bd7d61b70b8f610_720w.webp)

效果图



如果眉毛没有拆出来，则需要改源码使用逐材质自定义Stencil

在用UE的时候，或多或少都会对官方的Custom Stencil Value和Overlay Material有些不满：为什么这么好用的功能是逐Actor / Mesh的而不是逐材质的？

其实这玩意是能改到逐材质的，在Stencil的写入的部分本身就写入了材质信息：

![img](https://picx.zhimg.com/80/v2-2462c12607a818c586c31ee4c6beda13_720w.webp)

可以看到在输入里是有读到Material这个参数的。

首先需要声明的是，本人就是个半吊子写代码水平，这是本人拍脑袋的纯绿皮改动，有不对的地方还请各位爷斧正。

------

因此我们可以像改逐材质Overlay Material一样对Stencil也进行一波修改：

首先需要类似的在Material中开槽

在MaterialInterface.h中声明UProperty：

![img](https://pic3.zhimg.com/80/v2-becebb8229f417243225dd57fea0034a_720w.webp)

之后声明对应的Get函数的[纯虚函数](https://zhida.zhihu.com/search?q=纯虚函数&zhida_source=entity&is_preview=1)用于之后的覆写

![img](https://pic1.zhimg.com/80/v2-578508684c80f5b8b46408d75e0a5c78_720w.webp)

在Material.h中声明覆写Get函数

![img](https://pic4.zhimg.com/80/v2-b165efce4492ac1b81ca4c77e6b8eb33_720w.webp)

![img](https://pic4.zhimg.com/80/v2-adfab8ca45447f57d0b6d95f96748e37_720w.webp)



MaterialInstance中覆写Get函数

![img](https://picx.zhimg.com/80/v2-c23b7830769eefb4bf258b3260af6adf_720w.webp)

同时重新声明两个Instance变量槽，主要是懒得写覆写变量那一堆东西了。

![img](https://pic3.zhimg.com/80/v2-c53ff3a1a0287946960c8ef41b14f50e_720w.webp)

并将Get函数实现，此处需要判断是否有母材质，并判断是否开启了材质实例的覆写开关，如果开了则直接用材质实例的输入，否则用母材质的。

![img](https://pic4.zhimg.com/80/v2-0251f51dd321d9bb58054d5e01ec22a7_720w.webp)

MaterialShared中声明Get函数

![img](https://pica.zhimg.com/80/v2-cc7d184b8e0fd88535e530768aee102e_720w.webp)

![img](https://pic1.zhimg.com/80/v2-3dab639ae82e03b238adcaa71342cd9c_720w.webp)

![img](https://pic2.zhimg.com/80/v2-032519ac4ac4d4b9349eef2cf603330d_720w.webp)

MaterialEditorInstanceConstant中声明变量

![img](https://pic4.zhimg.com/80/v2-96fbe967d3fb2eb4e2fb7bbb62ece55f_720w.webp)

MaterialInstanceEditor和PreviewMaterial中记录变量修改

![img](https://pic1.zhimg.com/80/v2-e6e2a99dcdcd64c8cecb5bb41e8a7e38_720w.webp)

![img](https://pic1.zhimg.com/80/v2-37cb619b710700011f61ef24093f40da_720w.webp)

至此材质的槽修改就玩成了，其实写入CustomStencil就一步，只是加槽比较麻烦。

在CustomDepthRendering中的TryAddMeshBatch函数中有这么一步

![img](https://pic4.zhimg.com/80/v2-b6512f003e867796fa2d06b5802475f5_720w.webp)

这个PrimitiveSceneProxy就是官方放CustomStencil槽的地方，而官方的CustomDepth开关在AddMeshBatch

![img](https://pic1.zhimg.com/80/v2-7d5e508c9009d318fa9abf0e8bbd0284_720w.webp)

因为不想改动太大，因此将功能设计为了需要开启整个模型的CustomDepth逐材质的custom stencil才生效。

在TryAddMeshBatch中做如下改动

![img](https://picx.zhimg.com/80/v2-42424612c994d480ed76e00e6bad8911_720w.webp)

如果开了材质的Custom Stencil开关则直接以材质的Stencil为准，而如果材质的Stencil为0则忽略这个材质的Stencil（不写入Stencil，相当于单材质关闭Stencil），如果没有开材质的Stencil则用Mesh的Stencil



![img](https://pic2.zhimg.com/80/v2-415f68ccc03292ec5cd62579718dd353_720w.webp)

最终效果，可以实现很多以前需要拆模型才能实现的事情了





方式二：卡渲中眉毛透过头发基本是常规操作了，大部分是通过模板测试做的。之前遇到过一个小众情况，眉毛mesh没有单独拆出来，导致无法使用模板测试，故尝试使用深度偏移做透明眉毛

原理和代码也很简单，一句话概括就是，在相机空间中，对深度做一点偏移

```text
Varyings vert(Attributes input)
{    
    Varyings output = (Varyings)0;
    VertexPositionInputs positionInputs = GetVertexPositionInputs(input.positionOS.xyz);
    output.positionCS = positionInputs.positionCS;
       
    float3 positionVS = positionInputs.positionVS;
    positionVS.z += _EyebrowOffsetZ; //眉毛偏移深度
    float4 positionCS = TransformWViewToHClip(positionVS);
    float depth = positionCS.z / positionCS.w;
    output.positionCS.z = depth * output.positionCS.w; //把偏移后的深度赋值到裁切空间

    return output;
}
```

这里用的是[布洛妮娅](https://zhida.zhihu.com/search?q=布洛妮娅&zhida_source=entity&is_preview=1)的模型，眉毛是拆出来的。没拆出来的话，可以用顶点色等区分一下，只画眉毛部分即可

![img](https://picx.zhimg.com/80/v2-191daca223d4ad5bf9bba5b13980895d_720w.webp)

正面效果

有个小问题，侧边看时，透明眉毛会很奇怪

![img](https://pica.zhimg.com/80/v2-dd6ae692e95d450c8cfa6492599c66d0_720w.webp)

侧面错误效果

解决办法时，在相机旋转值侧面时，减少透明度

```text
Varyings vert(Attributes input)
{    
    - - - -
    
    //根据相机与角色Forward夹角，减少透明度
    float cos = dot(_WorldSpaceCameraPos - positionInputs.positionWS, _CharacterForward);
    output.color.a = saturate(lerp(cos, 1, _EyebrowRotFadeout));

    return output;
}
```

![动图封面](https://pic2.zhimg.com/v2-434f03d8ba0693001121283e005aac59_b.jpg)



同时可以作用于眼睛。





## ComputeShader存储逐物体信息



## 拓展Gbuffer

应用：

1.使用Custom Buffer当成开关，用来分离卡通Specular和写实Specular，区分F0的计算，卡通不需要金属度，可以在材质里切换。也可以用来分离各向异性，分离普通材质和头发材质，这样就不用为头发单独写一个ShadingModel，节省位宽。

![img](./imgs/1.png)



2.写入ilm等需要的特殊RT数据

例如：

GBuffer1.rgb=常规前向渲染结果（角色屏幕空间边缘光除外，屏幕空间边缘光在DefferdLighting中做）;

GBuffer1.rgb=Nomral;

GBuffer1.a=SpecularAreaMask;

GBuffer2.a=ShadowAreaMask;





GBuffer2.r=RimAreaMask(区分强弱有无);

GBuffer2.g=区分身体不同部位(Mask)；

GBuffer2.b=待定。



GBuffer2.a=Pixel Local Storage(在DefferdLight中区分材质的IDmask)

GBuffer3=Depth/Stencil;

其中区分GBuffer2.a的通道信息较为重要，举个例子：脸、头发、身体、皮肤在处理光照的时候还是有较大不同，可以通过GBuffer2.g 和GBuffer2.a区分出脸和Body中皮肤的部分使用同一种光照方式保证脸和下巴的光照一致。

![img](https://pic2.zhimg.com/80/v2-d1594bfbaf61ee01cc3356fe22c617c5_720w.webp)

GBuffer2.a在DefferdLight解码

3.用来存储任何trick需要的数据

缺点：增加GBuffer在移动端无法使用，性能消耗大。





### UnityHdrp拓展GBuffer

### 一、简介

首先我们简单梳理一下hdrp 延时渲染大致思路，便于之后展开。

![img](https://pic4.zhimg.com/80/v2-fb5d6043f1b598de1e03eb564dc5725b_720w.webp)

主要看这两个pass，Gbuffer将和光照无关的模型表面特性记录到屏幕空间的4张rt上，然后在deferred Lighting阶段统一计算着色。

假设场景中n个物体，m个光源

- Forward每个物体都要计算m次光源，总共计算 m x n， 多光源下性能堪忧。
- Gbuffer 绘制物体时不考虑光源计算m次，deferred Lighting绘制光照时拥有所有物体信息，只需要遍历一遍所有光源，总共m+n次，优化[就在这里](https://zhida.zhihu.com/search?content_id=230359650&content_type=Article&match_order=1&q=就在这里&zhida_source=entity)。同时因为将表面特性同时记录下来了，因此着色阶段可以访问相邻像素，做到forward做不到的事情，缺点就是带宽大。

### 二、起因

![img](https://pica.zhimg.com/80/v2-f197fd15288535869d5680bcd464f62a_720w.webp)

gbuffer 4张主要分别记录了主颜色、[法线](https://zhida.zhihu.com/search?content_id=230359650&content_type=Article&match_order=1&q=法线&zhida_source=entity)、表面特性、gi。针对不同shader，第三张存不同含义的参数，并储存一个标记featureID作区分。

通常npr风格可以把第三张rt改为ilm贴图，但由于我希望npr渲染同时带有pbr风格，特别是希望保留原先hdrp效果（sss、[各向异性](https://zhida.zhihu.com/search?content_id=230359650&content_type=Article&match_order=1&q=各向异性&zhida_source=entity)、色散彩色）的基础上叠加npr阴影，因此我决定加一张rt。（正式项目谨慎取舍，且后面的方案也可以解决这个问题）

但遇到sdf阴影的时候，5张还是存不下了。

![img](https://pic1.zhimg.com/80/v2-974663b077f48c8738b0621f706580f2_720w.webp)

这是一个sdf阴影的大致算法，可以看到，不仅仅要额外存脸正方向侧方向（6个float)，还要存两份ilm的b通道，一正一反，具体取那个依据光照，gbuffer时只能全部存进去。这样别说5张，6张都不够用。正在我考虑怎么压缩数据的时候，某个[截帧](https://zhida.zhihu.com/search?content_id=230359650&content_type=Article&match_order=1&q=截帧&zhida_source=entity)带给我了思路。

### 三、解决方案

![img](https://pic3.zhimg.com/80/v2-933bfd63d3278a9137d412d4718e3fe4_720w.webp)

从某游戏的截帧看到，他在gbuffer阶段算出算出阴影蒙版存入，这意味着npr阴影最少只占一个比特位，那可有大量可以扣的空间。

这个做法妙就妙在：

- 通常卡渲[二值化](https://zhida.zhihu.com/search?content_id=230359650&content_type=Article&match_order=1&q=二值化&zhida_source=entity)阴影只需要考虑一个光源，打光用的点光源可以接受拥有过渡。因此计算次数是变成了n*1+m，基本还是没变。
- 二值化阴影基本也只需要知道主光方向，计算一个ndl，并不涉及复杂的光照运算，增加的性能开销可以忽略。
- 脸部sdf和衣服手绘ao阴影可以融合为一套，不需要打额外的标记位区分。

### 四、实现

1、在gbuffer获取光照方向

在com.unity.render-pipelines.high-definition@14.0.7\Runtime\RenderPipeline\HDRenderPipeline.Prepass.cs的RenderGBuffer重通过m_GpuLightsBuilder.directionalLights[0]传入自定义参数

![img](https://pic3.zhimg.com/80/v2-9447b2c960ff542f1f5eee067a127cbc_720w.webp)

注意，由c#传入的变量不能申明在CBUFFER内部，我们申明在LitProperties CBuffer_END之后。

![img](https://pic3.zhimg.com/80/v2-241eb02b5eac13cc137eeb25df1d85de_720w.webp)

然后LitData中传入surfaceData，lit.hlsl中拿到surfaceData压入gbuffer。deferred Lighting过程从gbuffer取到存入bsdfData，就可以在lightLoop中用于着色。（需要扩展lit.cs，自动生成lit.cs.hlsl）

### 五、小节

效果完成了，匿了。工作以后精力有限，可能写的有点虎头蛇尾，实在不好意思。

![img](https://pic4.zhimg.com/80/v2-b0236020e7781901b5241f2e4189797d_720w.webp)

![img](https://pic4.zhimg.com/80/v2-4a5e90d1bb096081aefac69a8d91656f_720w.webp)



另外，最近在抽空写hdrp mmd工程，目前已经开源。代码是自己写的都直接开源了，但模型资源由于有版权问题不收录到git工程，以下是git链接：[HDRP_MMD/HDRP_MMD at main · BlazeWYSB/HDRP_MMD (github.com)](https://link.zhihu.com/?target=https%3A//github.com/BlazeWYSB/HDRP_MMD/tree/main/HDRP_MMD)

## 自定义pass，描边

增加MeshDrawPipeline，能够让模块解耦，更灵活。前期这个管线就可以只负责FMeshDrawCommand的转换，而FMeshDrawCommand是完全无状态的，不需要像PrimitiveComponent那样维护各种变化更新，FMeshDrawCommand的职能就是记录渲染Mesh需要的shaders、资源绑定、Drawcall参数，在转换到RHI之前，可以对FMeshDrawCommand可控地排序、缓存、合并绘制。最后，SubmitMeshDrawCommands()将FMeshDrawCommand转换为RHICommandList指令。

添加一个Mesh Draw Pass主要需要实现三样东西

1. Mesh Draw Pass的Processor类
2. 定义VS和PS的类，以及Shader的实现（顶点渲染和像素渲染）
3. 调用RDG的Render函数

通过实现上述三种类或函数，再完成一些其他零散的修改和实现，即可完成自定义Pass的创建了。下面就来讲讲具体如何进行开发吧。

示例：

```
// ----------------------------------YK Engine Start-----------------------------------------
// Toon Base Pass Step 3

#pragma once

#include "DataDrivenShaderPlatformInfo.h"
#include "MeshPassProcessor.h"

#include "MeshMaterialShader.h"

//-------------------------------------YK Engine Start----------------------------------------
// Toon Buffer step 5-1
// // 用于获取ToonBufferTexture的FRDGTextureDesc，FRDGTextureDesc存储了texture的一些描述信息，如大小，格式，MipMap层数等
// FRDGTextureDesc GetToonBufferTextureDesc(FIntPoint Extent, ETextureCreateFlags CreateFlags);
// // 用于创建一张ToonBufferTexture
// FRDGTextureRef CreateToonBufferTexture(FRDGBuilder& GraphBuilder, FIntPoint Extent, ETextureCreateFlags CreateFlags, const TCHAR* Name);

struct FFastVramConfig;
void CreateToonBuffers(FRDGBuilder& GraphBuilder, FSceneTextures& SceneTexture, FIntPoint Extent, const FFastVramConfig& FastVRamConfig);

//-------------------------------------YK Engine End------------------------------------------

class FToonBasePassMeshProcessor : public FMeshPassProcessor
{
public:
    FToonBasePassMeshProcessor(
       const FScene* Scene,
       ERHIFeatureLevel::Type InFeatureLevel,
       const FSceneView* InViewIfDynamicMeshCommand,
       const FMeshPassProcessorRenderState& InPassDrawRenderState,
       FMeshPassDrawListContext* InDrawListContext
    );

    // 函数将会从引擎底层拿到MeshBatch，Material等资源
    // MeshBatch简单理解就是同一批次的网格
    // 我们通过这个函数筛选哪些Mesh需要绘制并调用Process()
    virtual void AddMeshBatch(
       const FMeshBatch& RESTRICT MeshBatch,
       uint64 BatchElementMask,
       const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy,
       int32 StaticMeshId = -1
    ) override final;

private:
    // 准备好数据(MeshBatch，要用什么shader绘制，shader参数，剔除方式，深度测试等)
    // 将数据传递给BuildMeshDrawCommands生成MeshDrawCommand
    // MeshDrawCommand是完整描述了一个Pass Draw Call的所有状态和数据，如shader绑定、顶点数据、索引数据、PSO缓存等
    // 之后引擎会把MeshDrawCommand转化为RHI命令进行渲染
    bool Process(
       const FMeshBatch& MeshBatch,
       uint64 BatchElementMask,
       int32 StaticMeshId,
       const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy,
       const FMaterialRenderProxy& RESTRICT MaterialRenderProxy,
       const FMaterial& RESTRICT MaterialResource,
       ERasterizerFillMode MeshFillMode,
       ERasterizerCullMode MeshCullMode
    );

    FMeshPassProcessorRenderState PassDrawRenderState;
};



//-----------------------------------------shader----------------------------------


class FToonBasePassVS : public FMeshMaterialShader
{
    DECLARE_SHADER_TYPE(FToonBasePassVS, MeshMaterial);

public:
    FToonBasePassVS() = default;
    FToonBasePassVS(const ShaderMetaType::CompiledShaderInitializerType& Initializer)
        : FMeshMaterialShader(Initializer)
    {

    }

    static void ModifyCompilationEnvironment(const FMaterialShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
    {}

    static bool ShouldCompilePermutation(const FMeshMaterialShaderPermutationParameters& Parameters)
    {
        return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5) &&
            (Parameters.VertexFactoryType->GetFName() == FName(TEXT("FLocalVertexFactory")) || 
                Parameters.VertexFactoryType->GetFName() == FName(TEXT("TGPUSkinVertexFactoryDefault")));
    }

    void GetShaderBindings(
        const FScene* Scene,
        ERHIFeatureLevel::Type FeatureLevel,
        const FPrimitiveSceneProxy* PrimitiveSceneProxy,
        const FMaterialRenderProxy& MaterialRenderProxy,
        const FMaterial& Material,
        const FMeshPassProcessorRenderState& DrawRenderState,
        const FMeshMaterialShaderElementData& ShaderElementData,
        FMeshDrawSingleShaderBindings& ShaderBindings) const
    {
        FMeshMaterialShader::GetShaderBindings(Scene, FeatureLevel, PrimitiveSceneProxy, MaterialRenderProxy, Material, DrawRenderState, ShaderElementData, ShaderBindings);
    }

};


class FToonBasePassPS : public FMeshMaterialShader
{
    DECLARE_SHADER_TYPE(FToonBasePassPS, MeshMaterial);

public:

    FToonBasePassPS() = default;
    FToonBasePassPS(const ShaderMetaType::CompiledShaderInitializerType& Initializer)
        : FMeshMaterialShader(Initializer)
    {
        // 这个用于绑定shader的参数InputColor，虽然shader中没有使用
        InputColor.Bind(Initializer.ParameterMap, TEXT("InputColor"));
    }

    static void ModifyCompilationEnvironment(const FMaterialShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
    {}

    static bool ShouldCompilePermutation(const FMeshMaterialShaderPermutationParameters& Parameters)
    {
        return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5) &&
            (Parameters.VertexFactoryType->GetFName() == FName(TEXT("FLocalVertexFactory")) || 
                Parameters.VertexFactoryType->GetFName() == FName(TEXT("TGPUSkinVertexFactoryDefault")));
    }

    void GetShaderBindings(
        const FScene* Scene,
        ERHIFeatureLevel::Type FeatureLevel,
        const FPrimitiveSceneProxy* PrimitiveSceneProxy,
        const FMaterialRenderProxy& MaterialRenderProxy,
        const FMaterial& Material,
        const FMeshPassProcessorRenderState& DrawRenderState,
        const FMeshMaterialShaderElementData& ShaderElementData,
        FMeshDrawSingleShaderBindings& ShaderBindings) const
    {
        FMeshMaterialShader::GetShaderBindings(Scene, FeatureLevel, PrimitiveSceneProxy, MaterialRenderProxy, Material, DrawRenderState, ShaderElementData, ShaderBindings);

        FVector3f Color(1.0, 0.0, 0.0);

        ShaderBindings.Add(InputColor, Color);
    }

    LAYOUT_FIELD(FShaderParameter, InputColor);
};


//-------------------------------------YK Engine End------------------------------------------
```

### Mesh Draw Pass的开发

首先还是一样，寻找定义Mesh Draw Pass的地方，在定义的枚举种添加我们自己的Pass名称

```cpp
//MeshPassProcessor.h
namespace EMeshPass
{
    enum Type : uint8
    {
        DepthPass,
        BasePass,
        AnisotropyPass,
        SkyPass,
        SingleLayerWaterPass,
        SingleLayerWaterDepthPrepass,
        CSMShadowDepth,
        VSMShadowDepth,
        Distortion,
        Velocity,
        TranslucentVelocity,
        TranslucencyStandard,
        TranslucencyStandardModulate,
        TranslucencyAfterDOF,
        TranslucencyAfterDOFModulate,
        TranslucencyAfterMotionBlur,
        TranslucencyAll, /** Drawing all translucency, regardless of separate or standard.  Used when drawing translucency outside of the main renderer, eg FRendererModule::DrawTile. */
        LightmapDensity,
        DebugViewMode, /** Any of EDebugViewShaderMode */
        CustomDepth,
        MobileBasePassCSM,  /** Mobile base pass with CSM shading enabled */
        VirtualTexture,
        LumenCardCapture,
        LumenCardNanite,
        LumenTranslucencyRadianceCacheMark,
        LumenFrontLayerTranslucencyGBuffer,
        DitheredLODFadingOutMaskPass, /** A mini depth pass used to mark pixels with dithered LOD fading out. Currently only used by ray tracing shadows. */
        NaniteMeshPass,
        MeshDecal,

#if WITH_EDITOR
        HitProxy,
        HitProxyOpaqueOnly,
        EditorLevelInstance,
        EditorSelection,
#endif
        OutlinePass,

        Num,
        NumBits = 6,
    };
}
```

并修改[静态检查](https://zhida.zhihu.com/search?q=静态检查&zhida_source=entity&is_preview=1)中Pass的数量

```cpp
inline const TCHAR* GetMeshPassName(EMeshPass::Type MeshPass)
{
    switch (MeshPass)
    {
    case EMeshPass::DepthPass: return TEXT("DepthPass");
    case EMeshPass::BasePass: return TEXT("BasePass");
    case EMeshPass::AnisotropyPass: return TEXT("AnisotropyPass");
    case EMeshPass::SkyPass: return TEXT("SkyPass");
    case EMeshPass::SingleLayerWaterPass: return TEXT("SingleLayerWaterPass");
    case EMeshPass::SingleLayerWaterDepthPrepass: return TEXT("SingleLayerWaterDepthPrepass");
    case EMeshPass::CSMShadowDepth: return TEXT("CSMShadowDepth");
    case EMeshPass::VSMShadowDepth: return TEXT("VSMShadowDepth");
    case EMeshPass::Distortion: return TEXT("Distortion");
    case EMeshPass::Velocity: return TEXT("Velocity");
    case EMeshPass::TranslucentVelocity: return TEXT("TranslucentVelocity");
    case EMeshPass::TranslucencyStandard: return TEXT("TranslucencyStandard");
    case EMeshPass::TranslucencyStandardModulate: return TEXT("TranslucencyStandardModulate");
    case EMeshPass::TranslucencyAfterDOF: return TEXT("TranslucencyAfterDOF");
    case EMeshPass::TranslucencyAfterDOFModulate: return TEXT("TranslucencyAfterDOFModulate");
    case EMeshPass::TranslucencyAfterMotionBlur: return TEXT("TranslucencyAfterMotionBlur");
    case EMeshPass::TranslucencyAll: return TEXT("TranslucencyAll");
    case EMeshPass::LightmapDensity: return TEXT("LightmapDensity");
    case EMeshPass::DebugViewMode: return TEXT("DebugViewMode");
    case EMeshPass::CustomDepth: return TEXT("CustomDepth");
    case EMeshPass::MobileBasePassCSM: return TEXT("MobileBasePassCSM");
    case EMeshPass::VirtualTexture: return TEXT("VirtualTexture");
    case EMeshPass::LumenCardCapture: return TEXT("LumenCardCapture");
    case EMeshPass::LumenCardNanite: return TEXT("LumenCardNanite");
    case EMeshPass::LumenTranslucencyRadianceCacheMark: return TEXT("LumenTranslucencyRadianceCacheMark");
    case EMeshPass::LumenFrontLayerTranslucencyGBuffer: return TEXT("LumenFrontLayerTranslucencyGBuffer");
    case EMeshPass::DitheredLODFadingOutMaskPass: return TEXT("DitheredLODFadingOutMaskPass");
    case EMeshPass::NaniteMeshPass: return TEXT("NaniteMeshPass");
    case EMeshPass::MeshDecal: return TEXT("MeshDecal");
#if WITH_EDITOR
    case EMeshPass::HitProxy: return TEXT("HitProxy");
    case EMeshPass::HitProxyOpaqueOnly: return TEXT("HitProxyOpaqueOnly");
    case EMeshPass::EditorLevelInstance: return TEXT("EditorLevelInstance");
    case EMeshPass::EditorSelection: return TEXT("EditorSelection");
#endif
    case EMeshPass::OutlinePass: return TEXT("OutlinePass");
    }

#if WITH_EDITOR
    static_assert(EMeshPass::Num == 30 + 4, "Need to update switch(MeshPass) after changing EMeshPass");
#else
    static_assert(EMeshPass::Num == 30, "Need to update switch(MeshPass) after changing EMeshPass");
#endif
```

在新版本的开发分支中，增加了对于PSO数量的静态检查，因此需要在FPSOCollectorCreateManager中修改MaxPSOCollectorCount的值为目前的Pass数量

```cpp
//PSOPrecache.h
class ENGINE_API FPSOCollectorCreateManager
{
public:

    constexpr static uint32 MaxPSOCollectorCount = 34;

    static PSOCollectorCreateFunction GetCreateFunction(EShadingPath ShadingPath, uint32 Index)
    {
        check(Index < MaxPSOCollectorCount);
        uint32 ShadingPathIdx = (uint32)ShadingPath;
        return JumpTable[ShadingPathIdx][Index];
    }

private:

    // Have to used fixed size array instead of TArray because of order of initialization of static member variables
    static PSOCollectorCreateFunction JumpTable[(uint32)EShadingPath::Num][MaxPSOCollectorCount];
    friend class FRegisterPSOCollectorCreateFunction;
};
```

接着创建一个新的[头文件](https://zhida.zhihu.com/search?q=头文件&zhida_source=entity&is_preview=1)和一个新的CPP文件，用来存放新的Processor类和Shader类的实现，这一步同样可以仿照UE本身的Pass的实现，在UE本身的Pass种，参照Custom Depth Pass是一个不错的选择，流程清晰，代码量少。

首先在头文件中实现Processor类的声明，在这个类中主要包含一个构造函数和两个[成员函数](https://zhida.zhihu.com/search?q=成员函数&zhida_source=entity&is_preview=1)

```cpp
//OutlinePassRendering.h
class FOutlinePassProcessor : public FMeshPassProcessor
{
public:
    FOutlinePassProcessor(
        const FScene* Scene,
        const FSceneView* InViewIfDynamicMeshCommand,
        const FMeshPassProcessorRenderState& InPassDrawRenderState,
        FMeshPassDrawListContext* InDrawListContext
    );

    virtual void AddMeshBatch(
        const FMeshBatch& RESTRICT MeshBatch,
        uint64 BatchElementMask,
        const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy,
        int32 StaticMeshId = -1
    ) override final;

private:
    bool Process(
        const FMeshBatch& MeshBatch,
        uint64 BatchElementMask,
        int32 StaticMeshId,
        const FPrimitiveSceneProxy* RESTRICT PrimitiveSceneProxy,
        const FMaterialRenderProxy& RESTRICT MaterialRenderProxy,
        const FMaterial& RESTRICT MaterialResource,
        ERasterizerFillMode MeshFillMode,
        ERasterizerCullMode MeshCullMode
    );

    FMeshPassProcessorRenderState PassDrawRenderState;
};
```

接着是VS和PS两个Shader类的实现，由于目前尚未实现材质中获取描边参数的接口，可以暂时把下面代码中获取参数的代码注释掉，转而传给Shader一个定值来测试功能是否能够正常使用

```cpp
//OutlinePassRendering.h
class FOutlineVS : public FMeshMaterialShader
{
    DECLARE_SHADER_TYPE(FOutlineVS, MeshMaterial);

public:
    FOutlineVS() = default;
    FOutlineVS(const ShaderMetaType::CompiledShaderInitializerType& Initializer)
        : FMeshMaterialShader(Initializer)
    {
        OutLineScale.Bind(Initializer.ParameterMap, TEXT("OutLineScale"));
    }

    static void ModifyCompilationEnvironment(const FMaterialShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
    {}

    static bool ShouldCompilePermutation(const FMeshMaterialShaderPermutationParameters& Parameters)
    {
        return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5) &&
            Parameters.MaterialParameters.bHasOutline && 
            (Parameters.VertexFactoryType->GetFName() == FName(TEXT("FLocalVertexFactory")) || 
                Parameters.VertexFactoryType->GetFName() == FName(TEXT("TGPUSkinVertexFactoryDefault")));
    }

    void GetShaderBindings(
        const FScene* Scene,
        ERHIFeatureLevel::Type FeatureLevel,
        const FPrimitiveSceneProxy* PrimitiveSceneProxy,
        const FMaterialRenderProxy& MaterialRenderProxy,
        const FMaterial& Material,
        const FMeshPassProcessorRenderState& DrawRenderState,
        const FMeshMaterialShaderElementData& ShaderElementData,
        FMeshDrawSingleShaderBindings& ShaderBindings) const
    {
        FMeshMaterialShader::GetShaderBindings(Scene, FeatureLevel, PrimitiveSceneProxy, MaterialRenderProxy, Material, DrawRenderState, ShaderElementData, ShaderBindings);

        // const float OutlineScale = Material.GetOutlineScale();
        ShaderBindings.Add(OutLineScale, 1.0);
    }

    LAYOUT_FIELD(FShaderParameter, OutLineScale);
};


class FOutlinePS : public FMeshMaterialShader
{
    DECLARE_SHADER_TYPE(FOutlinePS, MeshMaterial);

public:

    FOutlinePS() = default;
    FOutlinePS(const ShaderMetaType::CompiledShaderInitializerType& Initializer)
        : FMeshMaterialShader(Initializer)
    {
        OutLineColor.Bind(Initializer.ParameterMap, TEXT("OutLineColor"));
    }

    static void ModifyCompilationEnvironment(const FMaterialShaderPermutationParameters& Parameters, FShaderCompilerEnvironment& OutEnvironment)
    {}

    static bool ShouldCompilePermutation(const FMeshMaterialShaderPermutationParameters& Parameters)
    {
        return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5) &&
            Parameters.MaterialParameters.bHasOutline && 
            (Parameters.VertexFactoryType->GetFName() == FName(TEXT("FLocalVertexFactory")) || 
                Parameters.VertexFactoryType->GetFName() == FName(TEXT("TGPUSkinVertexFactoryDefault")));
    }

    void GetShaderBindings(
        const FScene* Scene,
        ERHIFeatureLevel::Type FeatureLevel,
        const FPrimitiveSceneProxy* PrimitiveSceneProxy,
        const FMaterialRenderProxy& MaterialRenderProxy,
        const FMaterial& Material,
        const FMeshPassProcessorRenderState& DrawRenderState,
        const FMeshMaterialShaderElementData& ShaderElementData,
        FMeshDrawSingleShaderBindings& ShaderBindings) const
    {
        FMeshMaterialShader::GetShaderBindings(Scene, FeatureLevel, PrimitiveSceneProxy, MaterialRenderProxy, Material, DrawRenderState, ShaderElementData, ShaderBindings);

        // const FLinearColor OutlineColor = Material.GetOutlineColor();
        FVector3f Color(1.0, 0.0, 0.0);

        ShaderBindings.Add(OutLineColor, Color);
    }

    LAYOUT_FIELD(FShaderParameter, OutLineColor);
};
```

整个Shader类的实现非常简单，主要可以分为以下几个部分

- `DECLARE_SHADER_TYPE`用于在UE中声明Shader的类型
- `LAYOUT_FIELD`用于声明Shader中能够传入的Uniform参数
- `ModifyCompilationEnvironment`用于在Shader中定义特定的宏
- `GetShaderBindings`用于绑定已经声明的Uniform参数

如此一来，Shader类这部分就基本算是完成了，但是也[不要忘了](https://zhida.zhihu.com/search?q=不要忘了&zhida_source=entity&is_preview=1)在CPP文件中将对应的Shader文件绑定到这个Shader类上，这样在编译之后UE才能找到对应的Shader文件

```cpp
//OutlinePassRendering.cpp
IMPLEMENT_MATERIAL_SHADER_TYPE(, FOutlineVS, TEXT("/Engine/Private/OutlinePassShader.usf"), TEXT("MainVS"), SF_Vertex);
IMPLEMENT_MATERIAL_SHADER_TYPE(, FOutlinePS, TEXT("/Engine/Private/OutlinePassShader.usf"), TEXT("MainPS"), SF_Pixel);
```

同时，新建一个usf文件用来实现描边绘制的Shader

```cpp
//OutlinePassShader.usf
#include "Common.ush"
#include "/Engine/Generated/Material.ush"
#include "/Engine/Generated/VertexFactory.ush"

struct FSimpleMeshPassVSToPS
{
    FVertexFactoryInterpolantsVSToPS FactoryInterpolants;
    float4 Position : SV_POSITION;
};

float OutLineScale;
float3 OutLineColor;

#if VERTEXSHADER
void MainVS(
    FVertexFactoryInput Input,
    out FSimpleMeshPassVSToPS Output)
{
    ResolvedView = ResolveView();

    FVertexFactoryIntermediates VFIntermediates = GetVertexFactoryIntermediates(Input);

    float4 WorldPos = VertexFactoryGetWorldPosition(Input, VFIntermediates);
    float3 WorldNormal = VertexFactoryGetWorldNormal(Input, VFIntermediates);

    float3x3 TangentToLocal = VertexFactoryGetTangentToLocal(Input, VFIntermediates);

    FMaterialVertexParameters VertexParameters = GetMaterialVertexParameters(Input, VFIntermediates, WorldPos.xyz, TangentToLocal);
    WorldPos.xyz += GetMaterialWorldPositionOffset(VertexParameters);
    WorldPos.xyz += WorldNormal * OutLineScale;

    float4 RasterizedWorldPosition = VertexFactoryGetRasterizedWorldPosition(Input, VFIntermediates, WorldPos);

    Output.FactoryInterpolants = VertexFactoryGetInterpolantsVSToPS(Input, VFIntermediates, VertexParameters);
    Output.Position = mul(RasterizedWorldPosition, ResolvedView.TranslatedWorldToClip);

    float2 ExtentDir = normalize(mul(float4(WorldNormal, 1.0f), ResolvedView.TranslatedWorldToClip).xy);
    float Scale = clamp(0.0f, 0.5f, Output.Position.w * 1.0f * 0.1f);
    Output.Position.xy += ExtentDir * Scale;
}
#endif // VERTEXSHADER

void MainPS(
    FSimpleMeshPassVSToPS Input,
    out float4 OutColor : SV_Target0)
{
    OutColor = float4(OutLineColor, 1.0);
}
```

接下来则是对Processor中三个函数的实现，同样，下面的实现也注释掉了目前还没有在Material中完成的接口部分

```cpp
//OutlinePassRendering.cpp
FOutlinePassProcessor::FOutlinePassProcessor(
    const FScene* Scene,
    const FSceneView* InViewIfDynamicMeshCommand,
    const FMeshPassProcessorRenderState& InPassDrawRenderState,
    FMeshPassDrawListContext* InDrawListContext)
:FMeshPassProcessor(Scene, Scene->GetFeatureLevel(), InViewIfDynamicMeshCommand, InDrawListContext),
PassDrawRenderState(InPassDrawRenderState)
{
    // PassDrawRenderState.SetViewUniformBuffer(Scene->UniformBuffers.ViewUniform);
    if (PassDrawRenderState.GetDepthStencilState() == nullptr)
    {
        PassDrawRenderState.SetDepthStencilState(TStaticDepthStencilState<false, CF_NotEqual>().GetRHI());
    }
    if (PassDrawRenderState.GetBlendState() == nullptr)
    {
        PassDrawRenderState.SetBlendState(TStaticBlendState<>().GetRHI());
    }
}

void FOutlinePassProcessor::AddMeshBatch(
    const FMeshBatch& MeshBatch,
    uint64 BatchElementMask,
    const FPrimitiveSceneProxy* PrimitiveSceneProxy,
    int32 StaticMeshId)
{
    const FMaterialRenderProxy* MaterialRenderProxy = MeshBatch.MaterialRenderProxy;
    const FMaterialRenderProxy* FallBackMaterialRenderProxyPtr = nullptr;
    const FMaterial* Material = MaterialRenderProxy->GetMaterialNoFallback(FeatureLevel);

    // only set in Material will draw outline
    if (Material != nullptr && Material->GetRenderingThreadShaderMap() /*&& Material->HasOutline()*/)
    {
        // Determine the mesh's material and blend mode.
        const EBlendMode BlendMode = Material->GetBlendMode();

        bool bResult = true;
        if (BlendMode == BLEND_Opaque)
        {
            Process(
                MeshBatch,
                BatchElementMask,
                StaticMeshId,
                PrimitiveSceneProxy,
                *MaterialRenderProxy,
                *Material,
                FM_Solid,
                CM_CCW);
        }
    }
}

bool FOutlinePassProcessor::Process(
    const FMeshBatch& MeshBatch,
    uint64 BatchElementMask,
    int32 StaticMeshId,
    const FPrimitiveSceneProxy* PrimitiveSceneProxy,
    const FMaterialRenderProxy& MaterialRenderProxy,
    const FMaterial& RESTRICT MaterialResource,
    ERasterizerFillMode MeshFillMode,
    ERasterizerCullMode MeshCullMode)
{
    const FVertexFactory* VertexFactory = MeshBatch.VertexFactory;

    TMeshProcessorShaders<FOutlineVS, FOutlinePS> OutlineShaders;

    {
        FMaterialShaderTypes ShaderTypes;
        ShaderTypes.AddShaderType<FOutlineVS>();
        ShaderTypes.AddShaderType<FOutlinePS>();

        const FVertexFactoryType* VertexFactoryType = VertexFactory->GetType();

        FMaterialShaders Shaders;
        if (!MaterialResource.TryGetShaders(ShaderTypes, VertexFactoryType, Shaders))
        {
            UE_LOG(LogShaders, Warning, TEXT("Shader Not Found!"));
            return false;
        }

        Shaders.TryGetVertexShader(OutlineShaders.VertexShader);
        Shaders.TryGetPixelShader(OutlineShaders.PixelShader);
    }


    FMeshMaterialShaderElementData ShaderElementData;
    ShaderElementData.InitializeMeshMaterialData(ViewIfDynamicMeshCommand, PrimitiveSceneProxy, MeshBatch, StaticMeshId, false);

    const FMeshDrawCommandSortKey SortKey = CalculateMeshStaticSortKey(OutlineShaders.VertexShader, OutlineShaders.PixelShader);

    PassDrawRenderState.SetDepthStencilState(
    TStaticDepthStencilState<
    true, CF_GreaterEqual,// Enable DepthTest, It reverse about OpenGL(which is less)
    false, CF_Never, SO_Keep, SO_Keep, SO_Keep,
    false, CF_Never, SO_Keep, SO_Keep, SO_Keep,// enable stencil test when cull back
    0x00,// disable stencil read
    0x00>// disable stencil write
    ::GetRHI());
    PassDrawRenderState.SetStencilRef(0);

    BuildMeshDrawCommands(
        MeshBatch,
        BatchElementMask,
        PrimitiveSceneProxy,
        MaterialRenderProxy,
        MaterialResource,
        PassDrawRenderState,
        OutlineShaders,
        MeshFillMode,
        MeshCullMode,
        SortKey,
        EMeshPassFeatures::Default,
        ShaderElementData
    );

    return true;
}
```

这段代码看似复杂，实在主要完成了以下几个部分的功能

- 构造函数中主要完成对渲染状态的重置和清零
- 在`AddMeshBatch`中，则主要用来收集需要在该Pass中进行绘制的Mesh，同时调用`Process`函数，实现主要的功能
- 在`Process`中，主要完成了以下几件事情，获取Shader，设置渲染状态，以及调用`BuildMeshDrawCommands`构建渲染指令，而这些渲染指令则是最终我们在RDG中去执行的渲染指令

UE对[图形渲染](https://zhida.zhihu.com/search?q=图形渲染&zhida_source=entity&is_preview=1)的实现做了很多封装，同时又因为其自身管线的复杂程度，导致其自身的工程实现非常重，但是从另一方面来看，在实现了上述的Processor之后，渲染所需要的准备就基本上算是完成了，你会发现在实现的过程中并没有接触到图形API相关的概念，而是把[注意力集中](https://zhida.zhihu.com/search?q=注意力集中&zhida_source=entity&is_preview=1)到了对Mesh的处理以及对渲染状态的处理上，所以UE的这套管线封装，在我看来有利有弊，也算是一把双刃剑吧。

但是仅仅是这样子还远远不能让这个Pass跑起来，我们还需要再添加一些另外的东西。

首先是这个Processor的注册

```cpp
//OutlinePassRendering.cpp
void SetupOutlinePassState(FMeshPassProcessorRenderState& DrawRenderState)
{
    DrawRenderState.SetDepthStencilState(TStaticDepthStencilState<true, CF_LessEqual>().GetRHI());
}

FMeshPassProcessor* CreateOutlinePassProcessor(const FScene* Scene, const FSceneView* InViewIfDynamicMeshCommand, FMeshPassDrawListContext* InDrawListContext)
{
    FMeshPassProcessorRenderState OutlinePassState;
    SetupOutlinePassState(OutlinePassState);
    return new FOutlinePassProcessor(Scene, InViewIfDynamicMeshCommand, OutlinePassState, InDrawListContext);
}

FRegisterPassProcessorCreateFunction RegisterOutlinePass(&CreateOutlinePassProcessor, EShadingPath::Deferred, EMeshPass::OutlinePass, EMeshPassFlags::CachedMeshCommands | EMeshPassFlags::MainView);
```

在注册完成之后，UE会替我们去创建这个Processor，而不需要我们自己去构造这个Processor的实例对象了

接着，在DeferredShadingRenderer中声明Render函数

```cpp
//DeferredShadingRenderer.h
void RenderPrePass(FRDGBuilder& GraphBuilder, FRDGTextureRef SceneDepthTexture, FInstanceCullingManager& InstanceCullingManager);
void RenderPrePassHMD(FRDGBuilder& GraphBuilder, FRDGTextureRef SceneDepthTexture);

void RenderOutlinePass(FRDGBuilder& GraphBuilder, FSceneTextures& SceneTextures);

void RenderFog(
    FRDGBuilder& GraphBuilder,
    const FMinimalSceneTextures& SceneTextures,
    FRDGTextureRef LightShaftOcclusionTexture);
```

将Render的函数依旧放入Processor的CPP文件中，由于需要在RDG中传入绘制所需要的View以及SceneTexture，在此处还需使用Shader宏来定义UniformBuffer，以便传入绘制所需要的参数

```cpp
//OutlinePassRendering.cpp
DECLARE_CYCLE_STAT(TEXT("OutlinePass"), STAT_CLP_OutlinePass, STATGROUP_ParallelCommandListMarkers);

BEGIN_SHADER_PARAMETER_STRUCT(FOutlineMeshPassParameters, )
    SHADER_PARAMETER_STRUCT_REF(FViewUniformShaderParameters, View)
    SHADER_PARAMETER_STRUCT_INCLUDE(FInstanceCullingDrawParams, InstanceCullingDrawParams)
    RENDER_TARGET_BINDING_SLOTS()
END_SHADER_PARAMETER_STRUCT()

FOutlineMeshPassParameters* GetOutlinePassParameters(FRDGBuilder& GraphBuilder, const FViewInfo& View, FSceneTextures& SceneTextures)
{
    FOutlineMeshPassParameters* PassParameters = GraphBuilder.AllocParameters<FOutlineMeshPassParameters>();
    PassParameters->View = View.ViewUniformBuffer;

    PassParameters->RenderTargets[0] = FRenderTargetBinding(SceneTextures.Color.Target, ERenderTargetLoadAction::ELoad);
    PassParameters->RenderTargets.DepthStencil = FDepthStencilBinding(SceneTextures.Depth.Target, ERenderTargetLoadAction::ELoad, ERenderTargetLoadAction::ELoad, FExclusiveDepthStencil::DepthWrite_StencilWrite);

    return PassParameters;
}


void FDeferredShadingSceneRenderer::RenderOutlinePass(FRDGBuilder& GraphBuilder, FSceneTextures& SceneTextures)
{
    RDG_EVENT_SCOPE(GraphBuilder, "OutlinePass");
    RDG_CSV_STAT_EXCLUSIVE_SCOPE(GraphBuilder, RenderOutlinePass);

    SCOPED_NAMED_EVENT(FDeferredShadingSceneRenderer_RenderOutlinePass, FColor::Emerald);

    for(int32 ViewIndex = 0; ViewIndex < Views.Num(); ++ViewIndex)
    {
        FViewInfo& View = Views[ViewIndex];
        RDG_GPU_MASK_SCOPE(GraphBuilder, View.GPUMask);
        RDG_EVENT_SCOPE_CONDITIONAL(GraphBuilder, Views.Num() > 1, "View%d", ViewIndex);

        const bool bShouldRenderView = View.ShouldRenderView();
        if(bShouldRenderView)
        {
            FOutlineMeshPassParameters* PassParameters = GetOutlinePassParameters(GraphBuilder, View, SceneTextures);

            View.ParallelMeshDrawCommandPasses[EMeshPass::OutlinePass].BuildRenderingCommands(GraphBuilder, Scene->GPUScene, PassParameters->InstanceCullingDrawParams);

            GraphBuilder.AddPass(
                RDG_EVENT_NAME("OutlinePass"),
                PassParameters,
                ERDGPassFlags::Raster | ERDGPassFlags::SkipRenderPass,
                [this, &View, PassParameters](const FRDGPass* InPass, FRHICommandListImmediate& RHICmdList)
            {
                FRDGParallelCommandListSet ParallelCommandListSet(InPass, RHICmdList, GET_STATID(STAT_CLP_OutlinePass), *this, View, FParallelCommandListBindings(PassParameters));
                ParallelCommandListSet.SetHighPriority();
                SetStereoViewport(RHICmdList, View, 1.0f);
                View.ParallelMeshDrawCommandPasses[EMeshPass::OutlinePass].DispatchDraw(&ParallelCommandListSet, RHICmdList, &PassParameters->InstanceCullingDrawParams);
            });
        }
    }
}
```

接着，还需要在可见相关性函数中添加渲染指令的构建条件，这里同样注释掉还未实现的接口部分，以方便测试功能

```cpp
//SceneVisibility.cpp
// if (StaticMeshRelevance.bHasOutline)
{
    DrawCommandPacket.AddCommandsForMesh(PrimitiveIndex, PrimitiveSceneInfo, StaticMeshRelevance, StaticMesh, Scene, bCanCache, EMeshPass::OutlinePass);
}

if (StaticMeshRelevance.bUseAnisotropy)
{
    DrawCommandPacket.AddCommandsForMesh(PrimitiveIndex, PrimitiveSceneInfo, StaticMeshRelevance, StaticMesh, Scene, bCanCache, EMeshPass::AnisotropyPass);
}
```

最后，在Render[主函数](https://zhida.zhihu.com/search?q=主函数&zhida_source=entity&is_preview=1)中调用刚刚实现的Render函数，即可看到添加的自定义Pass运行起来了

```cpp
//DeferredShadingRenderer.cpp
RenderOutlinePass(GraphBuilder, SceneTextures);

AddSubsurfacePass(GraphBuilder, SceneTextures, Views);

Strata::AddStrataOpaqueRoughRefractionPasses(GraphBuilder, SceneTextures, Views);

{
    RenderHairStrandsSceneColorScattering(GraphBuilder, SceneTextures.Color.Target, Scene, Views);
}
```

到这里，描边绘制的功能显然是不完善的，那么下一篇就继续讲讲，如何针对这个功能，做一些编辑器的定制吧。

## 二.材质[参数传递](https://zhida.zhihu.com/search?q=参数传递&zhida_source=entity&is_preview=1)

### 1.定义参数与传递相关设置

首先我们需要在材质球中添加相关的参数

Engine\Source\Runtime\Engine\Classes\Materials\MaterialInterface.h

![img](https://pica.zhimg.com/80/v2-27e60f4106f24073bebf83f83d31807c_720w.webp)

一个UMaterial中会有多个FMaterial，分别储存不同质量等级。所以我们还需要到FMaterial中进行声明

Engine\Source\Runtime\Engine\Public\MaterialShared.h

![img](https://pica.zhimg.com/80/v2-9438a9c5249ca516a6c6a429602955f6_720w.webp)

并且还要到下面的FMaterialResource中

![img](https://pic2.zhimg.com/80/v2-f12959e28e0997a5ebc4d714f019b5ed_720w.webp)

之后需要到FMaterialShaderParameters中设置，用于之后Shader类

![img](https://picx.zhimg.com/80/v2-fa04194b815856072a11f5b90dbb9c7b_720w.webp)

![img](https://pic2.zhimg.com/80/v2-8a9d33c8af7d83bf83de099538e5cbe1_720w.webp)

在这些步骤准备完毕后，我们就可以在Shader中绑定并使用使用我们的参数了.

### 2.另一个方法传参

除此之外还有一个方法拿到我们的参数。（如下，但本文采用上面介绍的）

到cpp中,将数据传递到Shader并在Shader中接收,这里找一个合适的位置放入，因为接收的时候是按照cpp中顺序，所以cpp顺序要和ush中一致，记得和临近的上下文比较一下

Engine\Source\Runtime\Engine\Private\Materials\HLSLMaterialTranslator.cpp

![img](https://picx.zhimg.com/80/v2-1137197484dbc6a1f3997c52951ca5ef_720w.webp)

Engine\Shaders\Private\MaterialTemplate.ush

![img](https://pic2.zhimg.com/80/v2-463953e61d6c9797497b01be61d52f51_720w.webp)

之后就可以在Shader中使用函数获取。

## 三.添加Pass

### 1.添加Pass定义

Engine\Source\Runtime\Renderer\Public\MeshPassProcessor.h

首先我们需要添加我们的OutLinePass，并且天极爱过后下面的数量要增加

![img](https://pic2.zhimg.com/80/v2-cc04155cdb8ed96453d71a21aaa52687_720w.webp)

![img](https://pic3.zhimg.com/80/v2-0b8f9de1fda822da9de75a36d014e4e8_720w.webp)

![img](https://pic3.zhimg.com/80/v2-8f7bad05ad4cddb2aff0f819d9e377c0_720w.webp)

### 2.创建Shader

首先创建两个文件OutLinePassRendering.cpp和OutLinePassRendering.h到Engine\Source\Runtime\Renderer\Private

因为我们只是简单的描边Shader，就帮Shader类放在一起不单独创建文件了，放到Engine\Source\Runtime\Renderer\Private\ OutLinePassRendering.h，对于Shader类其中有三个主要的地方，一个构造函数绑定OutLineSize到VS中进行Offest，然后一个ShouldCompilePermutation通过我们的bUse来控制，还要一个就是Shader绑定，把OutLineSize传过去 。

![img](https://picx.zhimg.com/80/v2-0a4c60153e0792cb8c7faabfec7467b1_720w.webp)

之后来到PS,也是基本上相同的操作，添加一个OutLineColor，但这里要注意把LinearColor转为FVector3f

![img](https://pic2.zhimg.com/80/v2-1c72aa5e56801370798a0a5f3dac4fab_720w.webp)

除此之外还需要定义两个东西

![img](https://picx.zhimg.com/80/v2-e8061c8a7f83daa4a9b627f93c83ec33_720w.webp)

之后再到CPP里，实现一个GetoutLinePassShaders，我们参考DepthPass，去掉不必要部分

![img](https://pica.zhimg.com/80/v2-a6a11a374f770999efa250454eb47da0_720w.webp)

最后别忘了把Shader文件位置设置好，

![img](https://picx.zhimg.com/80/v2-de55d798fbf8493aa35bb9099e60af19_720w.webp)

这个文件是需要我们创建的， Engine\Shaders\Private\OutLine.usf，里面就是很简单的VS和PS，VS负责Offset，PS返回个颜色即可

![img](https://picx.zhimg.com/80/v2-e563b2b3b75dedf27327140b13231d03_720w.webp)

之后我们就可以准备创建MeshPassProcesser

### 3.创建MeshPassProcesser

MeshPassProcesser负责实现AddMeshBatch等，写指令到MeshDrawCommon中以便后续渲染

因为我们这里比较简单就是个OutLine，所以直接到SkyPass中抄过来就行Engine\Source\Runtime\Renderer\Private\SkyPassRendering把SkyPassRendering中的抄进来，把名字改一下然后在此基础上开始改

首先是.h中定义，就是很标准的一个继承FMeshPassProcessor类，然后一些核心方法

![img](https://pica.zhimg.com/80/v2-e2f7cada8990cfd8493d34661e4126f4_720w.webp)

之后到cpp中

首先是Processor的注册与创建

![img](https://pica.zhimg.com/80/v2-d63ef8d9d00a00ad36031c7d7efef6ec_720w.webp)

之后就是抄过来几个函数的修改，AddMeshBatch和TryAddMeshBatch基本不用改，但要注意我们是backfacing描边，需要剔除正面，CullMode改CM_CCW

![img](https://pic2.zhimg.com/80/v2-d4ac4666395389f16a04ea939eb78b89_720w.webp)

对于Process，在其中就是绑好Shader，设好渲染状态后去生存DrawCommands，我们把其中非必要的部分去掉。

![img](https://picx.zhimg.com/80/v2-7d1edb1ff7b5fd17964a28b93933745d_720w.webp)

### 4.创建调用渲染

之后我们还要为Mesh添加动态静态的Cache

来到Engine\Source\Runtime\Renderer\Private\SceneVisibility.cpp，在MarkRelevant中添加静态Cache

![img](https://pic4.zhimg.com/80/v2-5fed0de255279324f918959466694f9b_720w.webp)

并且到ComputeDynamicMeshRelevance添加动态Cache

![img](https://pic3.zhimg.com/80/v2-bc74c76be170197f949ff60cdf1bedc0_720w.webp)

为了渲染，我们需要一个Render函数

我们需要在现在DeferredShadingRenderer.h中创建申明，并且在我们的cpp中实现， Engine\Source\Runtime\Renderer\Private\DeferredShadingRenderer.h

![img](https://pic2.zhimg.com/80/v2-4b5652134716938ffbc5233e404cf4db_720w.webp)

之后来到我们的cpp中进行实现Engine\Source\Runtime\Renderer\Private\OutLinePassRendering.cpp

这部分主要模仿DepthPassRendering，把复杂的判断条件去除掉。

![img](https://pic4.zhimg.com/80/v2-cbeb3cf8e83d2b9c19c1991c5a8001c5_720w.webp)

这些都完成后 我们要到DeferredShadingRenderer.cpp中调用即可

放在灯光后雾效前，灯光后避免描边在雾浓的时候依然不衰减

![img](https://pic2.zhimg.com/80/v2-f1c3d538f6b72af0b03ccebc43967045_720w.webp)

至此主要的修改完毕，编译后可以看到如下效果

![img](https://pica.zhimg.com/80/v2-b1ec39848e8e85fa6192c522f14416c8_720w.webp)

## 四.修改材质实例MaterialInstance

如果我们为上图的材质创一个实例，会发现有效果但是没法在MaterialInstance中进行调整

![img](https://pica.zhimg.com/80/v2-9718a8c66b114129d1104fa77e5cfe86_720w.webp)

### 1.OverrideProperty添加

通过面板中现存的几个MaterialPropertyOverrides属性在源码中找，可以找到一个根据面板中的我们可以找到一个FMaterialInstanceBasePropertyOverrides，他储存了所有可以传递到MaterialInstance的Overrides，（LightMass也是一个同样的结构，不过没在这个类里面），这个文件在Engine\Classes\Materials\MaterialInstanceBasePropertyOverrides.h

我们首先来到里面，对着已经存在的照着抄一下，其内容就是一个bOverrdie和定义的属性，bOverride我觉得就是选框前面的那个打勾。

![img](https://pic1.zhimg.com/80/v2-4a9fcfb9ca544573e094f642706e24e2_720w.webp)

![img](https://picx.zhimg.com/80/v2-cbf286aac281eb177851d997a7021ca1_720w.webp)

同时我们还要把之后还要把他的构造函数和[运算符重载](https://zhida.zhihu.com/search?q=运算符重载&zhida_source=entity&is_preview=1)修改

Engine\Source\Runtime\Engine\Private\Materials\MaterialShared.cpp

![img](https://pic1.zhimg.com/80/v2-2bfd6d6d20f868d2c1302f197fb11bda_720w.webp)

![img](https://pic1.zhimg.com/80/v2-325710c2e3a5d76bbb02e2ee1df54fba_720w.webp)

### 2.参数传递修改

并且要把我们上面写过的一个地方修改一下

![img](https://pic1.zhimg.com/80/v2-e364785557e66b143610c968487df30e_720w.webp)

在MaterialInstance.h中看到有些参数定义，因为我们之前的参数是放到Interface里，所以在这里不需要重复定义，他是Interface子类，但是我们没有定义获取的函数，这样不利于我们获取父类的参数来继承，所以我们要先到Engine\Source\Runtime\Engine\Classes\Materials\MaterialInterface.h定义我们几个自定义属性的Get方法

![img](https://pic2.zhimg.com/80/v2-130a45f1880532260eac3060cfde755f_720w.webp)

并到CPP中Engine\Source\Runtime\Engine\Classes\Materials\MaterialInterface.cpp实现

![img](https://pic3.zhimg.com/80/v2-876d073ab8f25784f0728b9caf673472_720w.webp)

之后就可以回到Engine\Source\Runtime\Engine\Classes\Materials\MaterialInstance.h之中override一下方法

![img](https://pic2.zhimg.com/80/v2-c04e192b0d9b0ab79d548e563292c89f_720w.webp)

来到Engine\Source\Runtime\Engine\Private\Materials\MaterialInstance.cpp中写一下函数

![img](https://pica.zhimg.com/80/v2-35a1858116380b2c9fce09e56058a63a_720w.webp)

继续看MaterialInstance，里面他定义了一个FMaterialInstanceBasePropertyOverrides BasePropertyOverrides，并且有UpdateOverridableBaseProperties，HasOverridenBaseProperties方法用于数据更新，我们在其中找到相应部分进行修改，加入我们的属性

![img](https://pic3.zhimg.com/80/v2-d3214e70d9650e2975568e6def0bede4_720w.webp)

![img](https://pic3.zhimg.com/80/v2-4213426509c67866881904c28d330344_720w.webp)

![img](https://pica.zhimg.com/80/v2-4340ea0b8ee9b21a3683f139a8c7c8fa_720w.webp)

![img](https://pic4.zhimg.com/80/v2-cc9dc2e96e9254c567ecefb5a53960e7_720w.webp)

之后到Engine\Source\Runtime\Engine\Classes\Materials\MaterialInstanceDynamic.h也同样修改一下

![img](https://pic4.zhimg.com/80/v2-e4666e4f21a088d29dee5af008322a55_720w.webp)

![img](https://pica.zhimg.com/80/v2-899a84a4ab1c61f281ea6102734d04ec_720w.webp)

但其实现是放到了MaterialInstance.cpp，我们也照着样子写到那里

然后就是漫长的编译，正好去上课挂着慢慢编译，但回来编译完了，材质编辑器里还是没有出现我们定义的OutLine相关属性，我本以为是和MaterialInterface一样定义了就自动映射过去了，但是并没有，这个时候又继续看

### 3.编辑器显示参数

最后找了半天是有个CreateBasePropertyOverrideWidgets在MaterialEditorInstanceDetailCustomization.cpp之中，他负责创建材质编辑器中的界面

我们首先要到.h中去定义

Engine\Source\Editor\MaterialEditor\Private\MaterialEditorInstanceDetailCustomization.h

![img](https://picx.zhimg.com/80/v2-a57564c739a8af8fc90475a56507cefb_720w.webp)

之后到cpp中实现一下

![img](https://pica.zhimg.com/80/v2-c2fe0b754542046a981fa74362f47608_720w.webp)

![img](https://pic3.zhimg.com/80/v2-d511d052ee51f59a936e844ffd5609e0_720w.webp)

之后回到我们最初说的CreateBasePropertyOverrideWidgets函数中，照着进行修改

![img](https://pic3.zhimg.com/80/v2-b53ab778e6258391c6ec5d20be20a2d4_720w.webp)

![img](https://pica.zhimg.com/80/v2-9484690b7fae2e5fab167eabd3c2dd96_720w.webp)

此时编译后运行，材质编辑器中就有了界面

![img](https://pic2.zhimg.com/80/v2-f6540a746031c25e721a593eb4b48349_720w.webp)

但是你会发现怎么调整数值都没有反应，这个原因是因为我们的函数是定义在Interface里，但实际用到的UMaterial是没有重写方法的，所以一直用的父类返回默认值的方法，所以我们要对Umaterial重写方法，让他返回自己的当前值

所以到

Engine\Source\Runtime\Engine\Classes\Materials\Material.h

![img](https://pic4.zhimg.com/80/v2-30fa44b8faa7af68a8d52fcbf0497077_720w.webp)

之后到cpp中实现

Engine\Source\Runtime\Engine\Private\Materials\Material.cpp

![img](https://pica.zhimg.com/80/v2-708d05ac6adc8fc2fc7421762fcfb4be_720w.webp)

大功告成！

![img](https://pic2.zhimg.com/80/v2-195d2294da9d64311bb816569c289b09_720w.webp)

![img](https://pic4.zhimg.com/80/v2-03b81484fd3185e245269ed7737c7359_720w.webp)

![img](https://pica.zhimg.com/80/v2-cbfc9e66f37a25925ec8f3d887994180_720w.webp)

## 参考资料：

[YivanLee：虚幻4渲染编程(Shader篇)【第十三卷：定制自己的MeshDrawPass】101 赞同 · 18 评论文章![img](https://pic3.zhimg.com/v2-cce335207f674919c50d369cbae8cf00_180x120.jpg)](https://zhuanlan.zhihu.com/p/66545369)

[DiscoPaner：UE5 Add Custom MeshDrawPass64 赞同 · 45 评论文章![img](https://pic1.zhimg.com/v2-15ca17058a9ae3e0077294758795a594_180x120.jpg)](https://zhuanlan.zhihu.com/p/552283835)

[YivanLee：虚幻4乱改引擎卡通渲染篇【第二卷：初步描边勾线】70 赞同 · 7 评论文章![img](https://picx.zhimg.com/v2-2ac52ad4714b33d3da697148f0dbd05f_180x120.jpg)](https://zhuanlan.zhihu.com/p/37767350)

[Mr.ANT：【UE4.26.0】定制一个自己的MeshPass130 赞同 · 16 评论文章![img](https://pic1.zhimg.com/v2-d680497e59daff9b48d8e33a605ac8c0_180x120.jpg)](https://zhuanlan.zhihu.com/p/342681912)

[剖析虚幻渲染体系（09）- 材质体系www.cnblogs.com/timlly/p/15109132.html#922-umaterialinstance![img](https://pic4.zhimg.com/v2-5da8a25e354d0b0ac10ec07b2068cf13_ipico.jpg)](https://link.zhihu.com/?target=https%3A//www.cnblogs.com/timlly/p/15109132.html%23922-umaterialinstance)







## ToneMapping调整

Custom Tonemapping

[Amadeus：Unreal Unity Lut(look up table)笔记](https://zhuanlan.zhihu.com/p/702630527)

UE的Tonemapping使用的Film过于写实，Tonemap过的整体角色发白 饱和度 对比度都比较欠缺。我这边使用的是GT ToneMaping，没有做对单独角色的Tonemapping 之前在项目里面没有做过 ，强烈需要单独对角色处理需要两张ToneMap和Stencil去区分，不过在TAA下可能会有一些奇怪的Bug。

至于使用什么Tonemapping，可以多尝试一些风格让主美挑选，这玩意一定要项目早期确立后期一旦要改特效直接拿刀和你拼命。
